#!/usr/bin/env python
import os
import subprocess

import twosheds

HOME = os.environ['HOME']


def sh(command):
    """Run a command in the shell and capture the output."""
    return subprocess.check_output(command, shell=True)



HUMAN_ALIASES = {
    'copy': 'cp',
    'edit': '$EDITOR',
    'del': 'rm',
    'delete': 'rm',
    'goto': 'cd',
    'list': 'ls',
    'move': 'mv',
    'now': 'date',
    'whereami': 'pwd',
    'unixtime': 'date +$%s',
}

UTILITY_ALIASES = {
    # more intuitive xargs
    'args': 'xargs -0',
    # grep recursively. show line numbers and one line of context on either side
    'f': 'grep -rn -C 1',
    # find name
    'fn': 'find . -name',
     # Remove all local merged branches
    'gitclean': 'git branch --merged | grep -v ^\* | sed "s/^ *//" | xargs -n 1 git accept',
     # Remove all remote merged branches
    'gitcleanremote': 'git branch --merged | grep -v ^\* | sed "s/^ *//" | xargs -n 1 git accept',
    # list filenames by relative path
    'lr': 'find . -type f | sed "s#^./##',
    # check connection speed
    'pingme': 'ping google.com',
    'vimrc': '$EDITOR ~/.vimrc',
}

SHORT_ALIASES = {
    '..': 'cd ..',
    '...': 'cd ...',
    'c': 'cd',
    'e': '$EDITOR',
    'g': 'git',
    'gs': "git status -s",
    'l': 'ls',
    # show hidden files
    'la': 'ls -a',
    # show file metadata and symlinks pointers
    'll': 'ls -l',
    'v': '$EDITOR',
}

MASK_ALIASES = {
    # ask before overriding files
    'cp': 'cp -i',
    # sort variables
    'env': 'env | xargs -0 | sort',
    # color output
    'grep': 'grep --color=auto',
    # color output
    'ls': 'ls -G',
}

def get_aliases():
    return dict(HUMAN_ALIASES.items()
                + UTILITY_ALIASES.items()
                + SHORT_ALIASES.items())

os.environ['EDITOR'] = "vim"
os.environ['HOST'] = "$(uname -n)"
os.environ.setdefault('UNAME', "$(uname)")

PATH = ["%s/local/bin" % HOME,
        "%s/bin" % HOME,
        "/usr/local/bin",
        "/usr/bin",
        "/usr/sbin",
        "/usr/X11R6/bin",
        "/bin",
        "/sbin",
        ]
os.environ['PATH'] = ":".join(PATH)
os.environ['PYTHONSTARTUP'] = "%s/.pythonrc.py" % HOME
os.environ['VISUAL'] = os.environ['EDITOR']


class MyShell(twosheds.Shell):
    last_ls = ""
    last_gs = ""

    def __init__(self, *args, **kwargs):
        super(MyShell, self).__init__(*args, **kwargs)
        self.language.grammar.transforms.insert(
            1,
            twosheds.transform.AliasTransform(MASK_ALIASES)
        )

    @property
    def git_branch(self):
        """The current git branch."""
        try:
            return sh("git symbolic-ref --short HEAD 2> /dev/null").strip()
        except subprocess.CalledProcessError:
            return None

    @property
    def working_directory(self):
        """The current working directory."""
        try:
            pwd = os.getcwdu()
        except OSError:
            return "?"
        else:
            return self.language.grammar.transform(pwd, inverse=True)

    @property
    def working_directory_short(self):
        pwd = self.working_directory
        parts = pwd.split("/")
        if len(parts) == 1:
            return parts[0]
        else:
            return "%s/%s" % ("/".join(part[0]for part in parts[:-1]),
                              parts[-1])

    @property
    def prompt(self):
        working_directory = self.working_directory_short
        branch = self.git_branch
        if branch is not None:
            return "%s(%s) " % (working_directory, branch)
        else:
            return working_directory + " "

    @property
    def git_status(self):
        try:
            return sh("git status --porcelain 2> /dev/null")
        except subprocess.CalledProcessError:
            return None

    def auto_gs(self):
        """Automatically run ``git status`` if the output changes."""
        gs = self.git_status
        if gs is not None and gs != self.last_gs:
            self.last_gs = gs
            self.eval("git status -s")

    def auto_ls(self):
        """Automatically run ``ls`` if the output changes."""
        ls = sh("ls")
        if ls != self.last_ls:
            self.last_ls = ls
            self.eval("ls")

    def read(self):
        self.auto_ls()
        self.auto_gs()
        return super(MyShell, self).read()


shell = MyShell(aliases=get_aliases(), echo=True, exclude=[r'.*.pyc'])

def find_in(directory, q):
    return shell.eval('mdfind %s -onlyin %s' % (q, directory))
shell.language.semantics.builtins['findin'] = find_in

shell.interact("Hello!")
